import numpy as np


def trajectory_generation(initial_state: np.ndarray[(3, 3), np.float64], destination_state: np.ndarray[(3, 3), np.float64], time_resolution: np.float64 | float | int, acceleration_limits: np.ndarray[(None, 1), np.float64]):
    """
    Function computes a set of trajectories between two sets of states. The trajectories are time scaled to fit within
    an acceleration limit.
    :param initial_state: `numpy` array of shape (3, 3), initial values with columns of position, velocity, acceleration
    :param destination_state: `numpy` array of shape (3, 3), destination values with columns of position, velocity, acceleration
    :param time_resolution: int, samples per second to evaluate for trajectories
    :param acceleration_limits: `numpy` array of shape (3,), containing maximum acceleration limit for each N trajectory
    :return: A tuple containing four `numpy` arrays with data type `np.float64`:
             The first three, of shape (3, M), containing in order the position, velocity, and acceleration
             of the N trajectory at the M timestamps.
             The last one, of shape (1, M), containing the timestamps at which the trajectories were evaluated
    """

    # Calculate completion time
    traj_duration = acceleration_limited_completion_time(initial_state, destination_state, acceleration_limits)

    # Generate list of time points with desired resolution
    traj_times = np.arange(0, traj_duration + 1/time_resolution, 1/time_resolution)

    # Calculate polynomials and generate points along trajectory
    traj_position, traj_velocity, traj_acceleration = quintic_polynomial(initial_state, destination_state, traj_times)

    return traj_position, traj_velocity, traj_acceleration, traj_times


def quintic_polynomial(initial_state: np.ndarray[(None, 3), np.float64], destination_state: np.ndarray[(None, 3), np.float64], timestamps: np.ndarray[(1, None), np.float64]):
    """
    Function computes a set of trajectories as quintic polynomials between two sets of states,
    evaluating them at a given set of timestamps.
    :param initial_state: `numpy` array of shape (N, 3), initial values with columns of position, velocity, acceleration
    :param destination_state: `numpy` array of shape (N, 3), destination values with columns of position, velocity, acceleration
    :param timestamps: `numpy` array of shape (N,), list timestamps at which the outputs will be evaluated
    :return: A tuple containing three `numpy` arrays of shape (N, M) with data type `np.float64`,
             representing in order the position, velocity, and acceleration of the N trajectory at the M timestamps.
    """

    # Calculate coefficients with time unit
    a0 = initial_state[:, 0]
    a1 = initial_state[:, 1]
    a2 = initial_state[:, 2] / 2
    t_f = timestamps[-1]
    a3 = (-20*initial_state[:, 0] + 20*destination_state[:, 0] - (8*t_f*destination_state[:, 1]) - (12*t_f*initial_state[:, 1]) + (t_f**2*destination_state[:, 2]) - (3*t_f**2*initial_state[:, 2])) / (2*t_f**3)
    a4 = (30*initial_state[:, 0] - 30*destination_state[:, 0] + (14*t_f*destination_state[:, 1]) + (16*t_f*initial_state[:, 1]) - (2*t_f**2*destination_state[:, 2]) + (3*t_f**2*initial_state[:, 2])) / (2*t_f**4)
    a5 = (-12*initial_state[:, 0] + 12*destination_state[:, 0] - (6*t_f*destination_state[:, 1]) - (6*t_f*initial_state[:, 1]) + (t_f**2*destination_state[:, 2]) - (t_f**2*initial_state[:, 2])) / (2*t_f**5)

    # Evaluate trajectory polynomials
    position = a0[:, None] + a1[:, None]*timestamps[None, :] + a2[:, None]*timestamps[None, :]**2 + a3[:, None]*timestamps[None, :]**3 + a4[:, None]*timestamps[None, :]**4 + a5[:, None]*timestamps[None, :]**5
    velocity = a1[:, None] + 2*a2[:, None]*timestamps[None, :] + 3*a3[:, None]*timestamps[None, :]**2 + 4*a4[:, None]*timestamps[None, :]**3 + 5*a5[:, None]*timestamps[None, :]**4
    acceleration = 2*a2[:, None] + 6*a3[:, None]*timestamps[None, :] + 12*a4[:, None]*timestamps[None, :]**2 + 20*a5[:, None]*timestamps[None, :]**3

    return position, velocity, acceleration


def acceleration_limited_completion_time(initial_state: np.ndarray[(None, 3), np.float64], destination_state: np.ndarray[(None, 3), np.float64], acceleration_limits: np.ndarray[(None, 1), np.float64]):
    """
    Function computes the completion time for a trajectory generated by the quintic_polynomial() function to constrain
    the accelerations to be below their upper limits. It will attempt to get at least one acceleration close to the
    designated limit.
    :param initial_state: `numpy` array of shape (N, 3), initial values with columns of position, velocity, acceleration
    :param destination_state: `numpy` array of shape (N, 3), destination values with columns of position, velocity, acceleration
    :param acceleration_limits: `numpy` array of shape (N,), containing maximum acceleration limit for each N trajectory
    :return: A double containing the required completion time
    """

    # INTERNAL PARAMETERS:
    tolerance = 0.9999  # Tolerance scalar for acceleration limit
    completion_time = 1  # Initial completion time for polynomial in seconds

    # Calculate polynomial for acceleration with completion time of 1 second
    _, _, acceleration = quintic_polynomial(initial_state, destination_state, np.arange(0, completion_time + completion_time/100, completion_time/100))

    if np.any(np.max(np.abs(acceleration), axis=1) > acceleration_limits):
        # Determine upper and lower bound for completion time
        while np.any(np.max(np.abs(acceleration), axis=1) > acceleration_limits):
            completion_time *= 2
            _, _, acceleration = quintic_polynomial(initial_state, destination_state, np.arange(0, completion_time + completion_time/100, completion_time/100))  # Recalculate acceleration

            if completion_time >= 32:  # Failsafe in case the trajectory cannot be scaled (start or end above max limit)
                return completion_time

        # Define upper and lower bound for completion time
        completion_time_upper = completion_time
        completion_time_lower = completion_time / 2

        # Perform binary search to refine completion time
        while True:
            completion_time = completion_time_lower + (completion_time_upper - completion_time_lower)/2  # Pick new completion time between upper and lower bound
            _, _, acceleration = quintic_polynomial(initial_state, destination_state, np.arange(0, completion_time + completion_time/100, completion_time/100))  # Recalculate acceleration

            if completion_time_upper - completion_time_lower <= 1-tolerance:
                break
            elif np.any(np.max(np.abs(acceleration), axis=1) > acceleration_limits):
                completion_time_lower = completion_time  # At least one acceleration is too large, setting new lower bound for completion time
            elif np.all(np.max(np.abs(acceleration), axis=1) <= acceleration_limits):
                completion_time_upper = completion_time  # All accelerations are too small, setting new lower bound

    return completion_time
